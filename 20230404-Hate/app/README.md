# 문제:배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다
## ex) arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.
## arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다.

## 1.이해
배열 안의 중복을 없애고 기존 배열 순서에 맞게 다시 반환한다
## 2.계획
배열의 중복을 제거하면 그냥 끝?

## 3.실행
1.연속 중복을 제거한 후 나머지 숫자를 보관할 "result"라는 ArrayList를 만듭니다.
2.변수 "prev"를 -1로 초기화하여 배열에서 유효한 숫자가 아닌 이전 숫자를 나타냅니다.
3.배열 "arr"의 각 숫자 "num"을 반복합니다.
4.현재 숫자 "num"이 이전 숫자 "prev"와 같지 않으면 "result" ArrayList에 추가합니다.
5.현재 숫자 "num"과 같도록 "prev" 변수를 업데이트합니다.
6."result" ArrayList와 같은 크기의 정수 배열 "ans"를 만듭니다.
7."ans" 배열의 각 인덱스 "i"를 반복하고 해당 값을 "result" ArrayList의 해당 요소와 동일하게 설정합니다.
8.함수의 결과로 "ans" 배열을 반환합니다.

이 솔루션의 시간 복잡도는 O(n)이며 여기서 n은 입력 배열의 크기입니다. 결과를 저장하기 위해 ArrayList를 사용하기 때문에 공간 복잡도도 O(n)입니다.
## 4.분석
수 "prev"를 -1로 초기화할 때 입력 배열에 0에서 9 사이의 숫자가 포함되어 있기 때문에 유효한 숫자가 아닌 값을 할당합니다. 이는 현재 숫자를 이전 숫자와 처음 비교할 때 입력 배열의 어떤 숫자도 -1과 같을 수 없기 때문에 "num != prev" 조건은 항상 참입니다.


입력 배열을 반복하고 각 숫자를 이전 숫자와 비교할 때 "prev" 값을 현재 숫자와 동일하게 업데이트합니다. 즉, 이전 숫자와 같지 않은 새 숫자를 만날 때까지 "prev"는 항상 입력 배열의 이전 숫자 값을 보유합니다.


따라서 "prev"의 값은 초기에 -1로 설정되지만 배열을 반복하면서 입력 배열의 이전 숫자 값으로 업데이트됩니다.

## 5.반성
prev = -1을 하는 이유에 대해 이해를 하지 못했다. 또한 문제를 제대로 파악하지 않고 이해하지 않아 중복을 제거하기만 되는 걸로 생각했다.